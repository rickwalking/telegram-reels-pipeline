# Story 19-4: Assembly Report B-Roll Section

## Status: ready-for-dev

## Context

The assembly stage produces `assembly-report.json` but it currently lacks any B-roll metadata. With the two-pass overlay (19-1), auto-upscale (19-2), and alpha fade (19-3) now in place, the report needs a `broll_summary` section so QA and debugging can verify which clips were placed, whether they were upscaled, and how long each pass took.

## Story

As a pipeline developer,
I want the assembly report to include detailed B-roll insertion metadata,
so that QA and debugging can verify which clips were placed where and identify any issues.

## Acceptance Criteria

1. Given a successful `assemble_with_broll()` call, when the report is generated, then `assembly-report.json` includes a `broll_summary` section

2. Given `broll_summary`, when inspected, then it contains:
   - `clips_inserted`: count of successfully overlaid clips
   - `placements[]`: for each clip — variant, clip_path, insertion_point_s, duration_s, narrative_anchor, source, original_resolution, upscaled (bool)
   - `assembly_method`: `"two_pass_overlay"`
   - `pass_1_duration_ms`: time taken for base assembly
   - `pass_2_duration_ms`: time taken for overlay pass

3. Given an assembly with no B-roll clips, when the report is generated, then `broll_summary.clips_inserted` is 0 and `placements` is empty

4. Given the report, when it is generated, then it is produced by `reel_assembler.py` (not by the agent)

## Tasks

- [ ] Task 1: Add timing instrumentation around Pass 1 and Pass 2 in `assemble_with_broll()`
- [ ] Task 2: Track which clips were upscaled (original resolution from `_probe_resolution()`)
- [ ] Task 3: Create `BrollReport` frozen dataclass in reel_assembler (or use dict) for report data
- [ ] Task 4: Return report data alongside output Path from `assemble_with_broll()`
- [ ] Task 5: Write `assembly-report.json` with `broll_summary` section
- [ ] Task 6: Unit tests for report structure, zero-clip case, upscale tracking
- [ ] Task 7: Run full test suite, ruff, mypy — all pass

## Files Affected

| File | Change | Type |
|------|--------|------|
| `src/pipeline/infrastructure/adapters/reel_assembler.py` | Add timing, track upscale state, return report data | Infrastructure adapter |
| `tests/unit/infrastructure/test_reel_assembler_broll.py` | Test report structure | Tests |

## Dev Notes

### Architecture guidance

The `assemble_with_broll()` method at `reel_assembler.py:381` currently returns `Path`. To include report data, either:
- Return a `tuple[Path, dict]` (breaking change to callers)
- Store report on the assembler instance (mutable state, bad for frozen architecture)
- Write the report JSON directly inside the method (simplest, matches AC "generated by reel_assembler.py")

**Recommended:** Write report JSON to `output.with_name("assembly-report.json")` at the end of `assemble_with_broll()`. This is the simplest approach and matches the AC.

### Key locations

- `assemble_with_broll()`: `reel_assembler.py:381-464` — add `time.monotonic()` around Pass 1 (L444-447) and Pass 2 (L450-454)
- `_probe_resolution()`: `reel_assembler.py:72-101` — already returns `(width, height)`, use to track original resolution
- `_ensure_clip_resolution()`: `reel_assembler.py:128-143` — compare input/output paths to determine if upscale happened
- `CutawayManifest.clips`: each `CutawayClip` has `.source` field (ClipSource enum) for report

### Pattern

Use `time.monotonic()` for timing (not `time.time()`). Convert to ms with `int((end - start) * 1000)`.

Use atomic write pattern from CLAUDE.md: write to tmp, rename to final.

### Line length

120 chars max.

## Definition of Done

- `assembly-report.json` includes `broll_summary` with all specified fields
- Report generated by reel_assembler, not agent
- All tests pass, ruff clean, mypy clean
- Min 80% coverage on new code
