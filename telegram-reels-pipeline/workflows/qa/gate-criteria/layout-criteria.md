# QA Gate: Layout

## Evaluation Dimensions

### Dimension 1: Frame Classification (weight: 20/100)
- **Pass**: All frames classified with layout names matching KNOWN_LAYOUTS (snake_case: `side_by_side`, `speaker_focus`, `grid`), confidence >= 0.7
- **Rework**: Some frames have confidence between 0.5-0.69, or layout names not in KNOWN_LAYOUTS without escalation
- **Fail**: Frames with confidence < 0.5 and no escalation triggered, or invalid layout names
- **Prescriptive fix template**: "Frame at {timestamp}s has confidence {confidence}. Re-analyze or trigger escalation. Layout names must be snake_case matching KNOWN_LAYOUTS: side_by_side, speaker_focus, grid."

### Dimension 2: Transition Detection (weight: 15/100)
- **Pass**: Layout transitions correctly identified at boundary timestamps, segments properly split
- **Rework**: Transitions detected but boundary timestamps are imprecise (> 5s error)
- **Fail**: Obvious transitions missed (visible layout change between consecutive frames)
- **Prescriptive fix template**: "Layout transition missed between frames at {frame_a}s and {frame_b}s. These frames show different layouts ({layout_a} vs {layout_b}). Add a segment boundary."

### Dimension 3: Crop Region Validity (weight: 15/100)
- **Pass**: All crop regions within video bounds (x + width <= source_width, y + height <= source_height)
- **Rework**: Crop regions slightly exceed bounds (by < 10px)
- **Fail**: Crop regions significantly exceed video dimensions or are negative
- **Prescriptive fix template**: "Crop region for segment at {timestamp}s exceeds video bounds: x({x}) + width({width}) = {sum} > {source_width}. Adjust width to {corrected_width}."

### Dimension 4: Escalation Handling (weight: 15/100)
- **Pass**: Unknown layouts correctly escalated, or no unknown layouts found
- **Rework**: Unknown layout detected but escalation not triggered (confidence < 0.7 on non-KNOWN layout)
- **Fail**: Unknown layout silently assigned a KNOWN_LAYOUTS name (misclassification)
- **Prescriptive fix template**: "Layout '{name}' is not in KNOWN_LAYOUTS (side_by_side, speaker_focus, grid). Trigger escalation protocol for frame at {timestamp}s."

### Dimension 5: Segment Structure (weight: 25/100)
- **Pass**: `side_by_side` segments use appropriate crop strategy based on speaker separation: both-visible centered crop when speakers fit in one crop (`speaker_span <= 880px`), or per-speaker `sub_segments` when speakers are far apart; `speaker_focus` crops use face centroid from face map; `speaker_face_mapping` is present in `layout-analysis.json`; `representative_frame` included per segment; no sub_segment shorter than 5 seconds
- **Rework**: Sub-segments exist but some are shorter than 5s; face position map present but speaker_face_mapping missing; side_by_side uses per-speaker isolation when both-visible crop would work
- **Fail**: side_by_side crop isolates one speaker while completely cutting off the other visible speaker; segments shorter than 3 seconds exist; `face-position-map.json` missing or ignored
- **Prescriptive fix template**: "Segment at {start}s-{end}s is side_by_side. Speakers are {distance}px apart. {If distance <= 880: 'Both speakers fit in one 960px crop — use a single centered crop instead of sub_segments.' | If distance > 880: 'Speakers too far apart for single crop — use sub_segments with minimum 5s duration each.'}"
- **Cut Frequency Check**: Penalize if more than 3 crop-switch cuts occur in any 15-second window. Fix: "Merge short sub-segments (< 5s) into preceding segment."

### Dimension 6: Face Map Coverage (weight: 10/100)
- **Pass**: `face-position-map.json` exists, was generated by `detect_faces.py`, and has `person_count > 0`; face data was used in crop decisions
- **Rework**: Face map exists but has inconsistencies (e.g., `person_count` doesn't match detected faces in segments)
- **Fail**: `face-position-map.json` missing, empty, or not referenced in crop decisions
- **Prescriptive fix template**: "face-position-map.json is {missing|empty|not_referenced}. Run: python scripts/detect_faces.py <frames_dir> --output <workspace>/face-position-map.json. Use face data to compute crop regions."

## Critical Validation

- Layout names MUST be snake_case: `side_by_side`, `speaker_focus`, `grid`
- Using kebab-case (e.g., `side-by-side`) causes `has_unknown_layouts()` to return True → false escalation
- Confidence values are float 0.0-1.0 (validated by LayoutClassification.__post_init__)
- `side_by_side` segments use `sub_segments` ONLY when speakers are too far apart for a single crop. Both-visible centered crop (single `crop_region`) is preferred when both speakers fit.

## Scoring Rubric

- 90-100: Excellent — all frames classified, face-centered crops, proper sub-segments, face map used
- 70-89: Good — most frames classified, sub-segments present, minor issues
- 50-69: Acceptable — some low-confidence frames, sub-segment structure incomplete
- 30-49: Poor — rework required, significant classification, structure, or face map issues
- 0-29: Fail — unable to classify frames, no sub-segments, or face map missing

## Output Schema Requirements

Output JSON (`layout-analysis.json`) must contain:
- `classifications`: array of objects with `timestamp` (float), `layout_name` (string, snake_case), `confidence` (float 0.0-1.0)
- `speaker_face_mapping`: object mapping speaker IDs to face labels (e.g., `{"A": "Speaker_Left"}`)
- `segments`: array of objects with `start_seconds`, `end_seconds`, `layout_name`, `representative_frame`
  - For `side_by_side` (speakers far apart): includes `sub_segments` array (each with `start_seconds`, `end_seconds`, `crop_region`, `active_speaker`, `face_source`; minimum 5s duration)
  - For `side_by_side` (both visible): includes `crop_region` at segment level (same as speaker_focus) — preferred when speakers fit in one crop
  - For other layouts: includes `crop_region` at segment level
- `escalation_needed`: boolean
- `quality_predictions`: array of upscale factor predictions per segment
